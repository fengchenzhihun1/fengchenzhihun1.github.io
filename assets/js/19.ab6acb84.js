(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{239:function(a,v,_){"use strict";_.r(v);var l=_(0),t=Object(l.a)({},(function(){var a=this,v=a.$createElement,_=a._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"java8-学习"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java8-学习"}},[a._v("#")]),a._v(" java8 学习")]),a._v(" "),_("h2",{attrs:{id:"lambda表达式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#lambda表达式"}},[a._v("#")]),a._v(" LAMBDA表达式")]),a._v(" "),_("ul",[_("li",[a._v("Lambda表达式也被称为箭头函数、匿名函数、闭包")]),a._v(" "),_("li",[a._v("Lambda表达式体现的是轻量级函数式编程思想")]),a._v(" "),_("li",[a._v("、->、符合式Lambda表达式核心操作符合，符号左侧是操作参数，符号右侧是操作表达式")]),a._v(" "),_("li",[a._v("JDK8新特性")])]),a._v(" "),_("h2",{attrs:{id:"model-code-as-date"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#model-code-as-date"}},[a._v("#")]),a._v(" Model Code as Date")]),a._v(" "),_("ul",[_("li",[a._v("Model Code as Date,编码及数据，尽可能轻量级的将代码封装为数据")]),a._v(" "),_("li",[a._v("解决方案：接口&实现类（匿名内部类）")]),a._v(" "),_("li",[a._v("存在问题：语法冗余、this关键字、变量捕获、数据控制")])]),a._v(" "),_("h2",{attrs:{id:"为什么要用lambda表达式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用lambda表达式"}},[a._v("#")]),a._v(" 为什么要用Lambda表达式")]),a._v(" "),_("ul",[_("li",[a._v("它不是解决未知问题的新技术")]),a._v(" "),_("li",[a._v("对现有解决方案的语义化优化")]),a._v(" "),_("li",[a._v("需要根据实际需求考虑性能问题")])]),a._v(" "),_("h2",{attrs:{id:"lambda基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#lambda基础"}},[a._v("#")]),a._v(" Lambda基础")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("函数式接口")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("就是java类型系统中的接口")])]),a._v(" "),_("li",[_("p",[a._v("包含一个接口方法的特殊接口")])]),a._v(" "),_("li",[_("p",[a._v("语义化监测注解：@Functionallnterface")])]),a._v(" "),_("li",[_("p",[a._v("默认接口方法")])]),a._v(" "),_("li",[_("p",[a._v("静态接口方法")])])])]),a._v(" "),_("li",[_("p",[a._v("Lambda语法及使用")]),a._v(" "),_("p",[a._v("参数  -> 方法体")]),a._v(" "),_("ul",[_("li",[a._v("Lambda表达式基本语法\n"),_("ul",[_("li",[a._v("声明 函数式接口声明")]),a._v(" "),_("li",[a._v("参数  不需要写类型（自动类型推导），如果只有一个参数不需要括号")]),a._v(" "),_("li",[a._v("操作符 ->")]),a._v(" "),_("li",[a._v("执行代码块 多行使用大括号，一行可以不使用大括号，且有返回值不需要return")])])]),a._v(" "),_("li",[a._v("带参数的Lambda表达式")]),a._v(" "),_("li",[a._v("带返回值的Lambda表达式")])])]),a._v(" "),_("li",[_("p",[a._v("java系统中的函数式接口")]),a._v(" "),_("ul",[_("li",[a._v("Predicate  test  接受T返回Boolean")]),a._v(" "),_("li",[a._v("Consumer accept 接受T 没有返回值")]),a._v(" "),_("li",[a._v("Function    apply  接受T返回R")]),a._v(" "),_("li",[a._v("UnaryOperator  接受T返回T")]),a._v(" "),_("li",[a._v("BinaryOperator  接受两个T，返回一个T对象结果")]),a._v(" "),_("li",[a._v("Suplier 不接受任何参数，直接通过get获取指定类型对象")])])]),a._v(" "),_("li",[_("p",[a._v("变量捕获")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("匿名内部类中的变量捕获")]),a._v(" "),_("p",[a._v("匿名内部中的this指的是匿名内部类")])]),a._v(" "),_("li",[_("p",[a._v("Lambda表达式中的变量捕获")]),a._v(" "),_("p",[a._v("Lambda所在的方法")])])])]),a._v(" "),_("li",[_("p",[a._v("类型检查")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("表达式类型检查")])]),a._v(" "),_("li",[_("p",[a._v("参数类型检查")])])])]),a._v(" "),_("li",[_("p",[a._v("Lambda表达式运行原理")]),a._v(" "),_("ul",[_("li",[a._v("javap -p App.class")]),a._v(" "),_("li",[a._v("java -Djdk.internal.lambda.dumpProxyClass App")])])])]),a._v(" "),_("h2",{attrs:{id:"lambda进阶"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#lambda进阶"}},[a._v("#")]),a._v(" Lambda进阶")]),a._v(" "),_("ul",[_("li",[a._v("方法引用\n"),_("ul",[_("li",[a._v("静态")]),a._v(" "),_("li",[a._v("实例")]),a._v(" "),_("li",[a._v("构造")])])]),a._v(" "),_("li",[a._v("Stream API")]),a._v(" "),_("li",[a._v("Stream操作原理")]),a._v(" "),_("li",[a._v("操作集合元素")])]),a._v(" "),_("h2",{attrs:{id:"stream"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#stream"}},[a._v("#")]),a._v(" stream")])])}),[],!1,null,null,null);v.default=t.exports}}]);